{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>There you can find documentation and link for all my projects :)</p> <p>My GitHub Profile</p> <p>List of all projects documentation:</p> <ul> <li>Toolbox</li> </ul>"},{"location":"toolbox/about/","title":"About","text":"<p>Toolbox is a framework that makes it easier to create games using Unity. Many frequently used things by programmers are taken into account in the toolbox and configured in such a way as to reduce the time and number of lines of code spent on them.</p> <p>Table of contents:</p> <ul> <li>Installing</li> <li>Setup</li> <li>Toolbox Settings</li> <li>MonoCached</li> <li>Updater</li> <li>Traveler</li> <li>Pooler</li> <li>Messenger (WIP)</li> <li>Audio Player (WIP)</li> <li>Database (WIP)</li> </ul>"},{"location":"toolbox/audioplayer/","title":"Audio Player","text":""},{"location":"toolbox/audioplayer/#basics","title":"Basics","text":"<p><code>AudioPlayer</code> allows you to structurize sounds used in your project and manipulate them. It uses albums as containers for clips, each album can have it's own audio source component binded and can be controlled through mixer group.</p> <p>To add album go to Toolbox settings and click on 'Audio Player' tab. Here you can add a new album by clicking 'Add Album' button. Enter its name and decide if you want to use separate audio source, or use default. If you are using separate source, then you can define a mixer group for it if you want.</p> <p>After album setted up click on 'Add Clip' button to add new audio clip. Enter its name and select actual audio clip, you can preview it by clicking 'Play' button or stop playing by clicking 'Stop' button below the 'Play' button or right after 'Add Album' button.</p> <p></p>"},{"location":"toolbox/audioplayer/#playong-audios","title":"Playong audios","text":"<p>To play audio you can call <code>AudioPlayer.Play(...)</code> method. It takes 6 parameters:</p> <ul> <li>source: an album name.</li> <li>id: clip name</li> <li>volume: volume of an AudioSource component (by default = 1)</li> <li>pitch: pitch of an AudioSource component (by default = 1)</li> <li>loop: will audio clip be looped (by default = false)</li> <li>playType: play behaviour (by default = ONE_SHOT):<ul> <li>ONE_SHOT: plays clip even if another clip is playing</li> <li>STOP_THEN_PLAY: stops current playing clip if there is one and then plays provided clip</li> <li>NO_INTERRUPT: does nothing if other clip currently playing, otherwise plays it normally</li> </ul> </li> </ul>"},{"location":"toolbox/dependencies/","title":"Dependencies","text":"<p>Toolbox uses other packages to work properly, here yo can see all of them with links related.</p> <ul> <li>UniTask: used to easily work with async/await in unity environment</li> <li>Naughty Attributes: allowed to build pretty editor interface. such as scene name selectors.</li> <li>TypeReferences: allows <code>Messenger</code> to work in inspector, by choosing message class type you need.</li> </ul>"},{"location":"toolbox/install/","title":"Installing","text":""},{"location":"toolbox/install/#install-with-openupm","title":"Install with OpenUPM","text":"<p>Once you have the OpenUPM cli, run the following command:</p> <ul> <li>Go to your Unity project directory</li> </ul> <p><code>cd YOUR_UNITY_PROJECT_DIR</code></p> <ul> <li>Install package: com.volumebox.toolbox</li> </ul> <p><code>openupm add com.volumebox.toolbox</code></p> <p>Alternatively, merge the snippet to Packages/manifest.json </p> <pre><code>{\n    \"scopedRegistries\": [\n        {\n            \"name\": \"package.openupm.com\",\n            \"url\": \"https://package.openupm.com\",\n            \"scopes\": [\n              \"com.volumebox\"\n              \"com.openupm\"\n            ]\n        }\n    ],\n    \"dependencies\": {\n        \"com.volumebox.toolbox\": \"0.2.4\"\n    }\n}\n</code></pre>"},{"location":"toolbox/install/#install-via-package-manager","title":"Install via Package Manager","text":"<ul> <li>open Edit/Project Settings/Package Manager</li> <li> <p>add a new Scoped Registry (or edit the existing OpenUPM entry)</p> <p>Name: <code>package.openupm.com</code></p> <p>URL: <code>https://package.openupm.com</code></p> </li> <li> <p>add following scopes:</p> <p><code>com.volumebox.toolbox</code></p> <p><code>com.dbrizov</code></p> <p><code>com.solidalloy</code></p> <p><code>org.nuget</code></p> <p><code>com.cysharp</code></p> </li> <li> <p>click <code>Save</code> (or <code>Apply</code>)</p> </li> <li>open <code>My Registries</code> packages in package manager window</li> <li>install <code>VolumeBox Toolbox</code></li> </ul>"},{"location":"toolbox/messenger/","title":"Messenger","text":""},{"location":"toolbox/messenger/#basics","title":"Basics","text":"<p>Toolbox implements a publisher-subscriber pattern, that allows you to write minimally coupled code in fewer lines.  You can read more about publisher-subscriber pattern Here.</p> <p>To use this pattern you need to work with <code>Messenger</code> class, which allows you to subscribe and send messages by calling <code>Messenger.Subscribe&lt;T&gt;(...)</code> and <code>Messenger.Send&lt;T&gt;()</code> correspondingly.</p>"},{"location":"toolbox/messenger/#message","title":"Message","text":"<p>To work with messages you need to create one. <code>Message</code> is a basic class for all messages, just derive your message from it, add fields and properties and that's it.</p> <pre><code>public class PlayerReloadingMessage: Message { }\n\npublic class EnemyDiedMessage: Message\n{\n    public Enemy enemy;\n}\n</code></pre>"},{"location":"toolbox/messenger/#subscribing","title":"Subscribing","text":"<p>To subscribe to a message, you need provide its type and a callback to a <code>Messenger.Subscribe&lt;T&gt;(...)</code> method.</p> <pre><code>...\n\nprotected override void Rise()\n{\n    Messenger.Subscribe&lt;PlayerReloadingMessage&gt;(_ =&gt; OnPlayerReloading());\n    Messenger.Subscribe&lt;EnemyDiedMessage&gt;(m =&gt; OnEnemyDied(m));\n}\n\nprivate void OnPlayerReloading()\n{\n    // Do something when player reloading\n}\n\nprivate void OnEnemyDied(Enemy enemy)\n{\n    m_KilledEnemies.Add(enemy);\n}\n\n...\n</code></pre>"},{"location":"toolbox/messenger/#sending","title":"Sending","text":"<p>You can send messages in several ways:</p>"},{"location":"toolbox/messenger/#by-type","title":"By type","text":"<p>If you do not have additional data to provide with message, you can just provide message's type.</p> <pre><code>...\n\nMessenger.Send&lt;PlayerReloadingMessage&gt;();\n\n...\n</code></pre>"},{"location":"toolbox/messenger/#by-instance","title":"By instance","text":"<p>If you want to pass additional data to a message, you need to create an instance of it and provide it as a parameter.</p> <pre><code>...\n\nMessenger.Send(new EnemyDiedMessage { enemy = this });\n\n...\n</code></pre>"},{"location":"toolbox/messenger/#by-cached-variable","title":"By cached variable","text":"<p>If you often send a one type of message with different data, you can cache it and send it without creating a new instance.</p> <pre><code>...\n\nprivate GainedXPMessage m_GainedXPMessage = new GainedXPMessage();\n\n...\n\npublic void OnXpGained(int amount)\n{\n    //do related stuff\n\n    //update message's variable\n    m_GainedXPMessage.amount = amount; \n    //then send a message\n    Messenger.Send(m_GainedXPMessage);\n}\n\n...\n</code></pre>"},{"location":"toolbox/messenger/#binding","title":"Binding","text":"<p>You can bind your subscribe to a gameobject lifetime, so it will be automatically removed if gameobject destroyed to prevent memory leaks and errors. Just provide gameobject you want to bind as second parameter.</p> <pre><code>Messenger.Subscribe&lt;PlayerReloadingMessage&gt;(_ =&gt; OnPlayerReloading, gameObject);\n</code></pre>"},{"location":"toolbox/monocached/","title":"MonoCached","text":""},{"location":"toolbox/monocached/#basics","title":"Basics","text":"<p>Toolbox has its own update system, which wraps around Unity's basic update cycle and doing its own calculations.</p> <p><code>MonoCached</code> is the main component of this system. It is analogous to MonoBehaviour with some extra described below.</p> <p><code>MonoCached</code> has same update cycle related methods, but named differently. It is closely related to <code>Updater</code>, so you can precisely control lifetime and update behaviour of each object. Here are list of all \"overriden\" method recommended to use instead:</p> Basic Analogue <code>Awake</code> <code>Rise</code> <code>Start</code> <code>Ready</code> <code>Update</code> <code>Tick</code> <code>FixedUpdate</code> <code>FixedTick</code> <code>LateUpdate</code> <code>LateTick</code> <code>OnDestroy</code> <code>Destroyed</code> <code>OnEnable</code> <code>OnActivate</code> <code>OnDisable</code> <code>OnDeactivate</code> <p>Also, <code>MonoCached</code> has methods and properties to control its lifecycle:</p> Method Description <code>Pause</code> Pauses execution of <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods <code>Resume</code> Resumes execution of <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods <code>EnableGameObject</code> Enables <code>gameObject</code> on which component placed <code>DisableGameObject</code> Disables <code>gameObject</code> on which component placed <code>ProcessIfInactiveSelf</code> Bool property. If enabled, then <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods will be executed even if gameObject inactive self <code>ProcessIfInactiveInHierarchy</code> Bool property. If enabled, then <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods will be executed even if gameObject inactive in hierarchy <code>delta</code> Float property. Delta time, controlled by timescale, interval etc <code>fixedDelta</code> Float property. Fixed delta time, controlled by timescale, interval etc <code>Interval</code> Float property. Sets the interval between calling <code>Tick</code>, <code>FixedTick</code> and <code>LateTick</code> methods. Delta time then will be a sum of deltas between last call and next. If setted to 0, then it works usually <p>To use full power of 'Toolbox', just derive your class from <code>MonoCached</code> and override method you need.</p> <p>Here's some example:</p> <pre><code>public class Rocket: MonoCached\n{\n    private float speed = 10;\n    private SpriteRenderer spriteRenderer;\n\n    protected override void Rise()\n    {\n        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();\n    }\n\n    protected override void Tick()\n    {\n        //Here we reducing update calls if we don't see the object\n        if(/*There are some logic to check if object is out of screen*/)\n        {\n            Interval = 1;\n        }\n        else\n        {\n            Interval = 0;\n        }\n\n        //Delta time will be a sum of deltas on every frame between last call of this method and current\n        transform.position = transform.forward * speed * delta;\n    }\n}\n</code></pre> <p>Because of <code>MonoCached</code> derived from MonoBehaviour you can still use <code>Awake</code>, <code>Update</code>, etc...</p>"},{"location":"toolbox/pooler/","title":"Pooler","text":""},{"location":"toolbox/pooler/#basics","title":"Basics","text":"<p>Let's start this topic by defining what 'Pool' means. Here you can read all about this pattern: </p> <p>Object pool pattern.</p> <p>In simple words, use pool patter when you are working with a lot of instantiating and destroying objects.</p> <p>Toolbox has his own implementation of this pattern. Simple way you can use it is to define pools you need in Toolbox settings and call <code>Pooler.Spawn(...)</code> where you need.</p> <pre><code>...\n\npublic void Shoot()\n{\n    var bullet = Pooler.Spawn(\"Bullet\", currentWeapon.tip.position, Quaternion.identity).GetComponent&lt;Bullet&gt;();\n    bullet.StartMovingForward();\n}\n\n...\n</code></pre> <p>Here you can see that to create pool you need to define it's tag, prefab and capacity.</p> <p>To create pools, which will be initialized on start, go to 'Toolbox Settings' and  click on 'Pooler' tab. Here you can add or remove pools, change it's tags, prefabs and capacity.</p> <p></p> <p>Capacity of the pool describes how many objects you can spawn without instantiating a new one, when it's all over.</p> <p>You can create pool manually in code by calling <code>Pooler.TryAddPool(PoolData poolToAdd)</code> or <code>Pooler.TryAddPool(string tag, GameObject prefab, int capacity)</code>. Pool won't be added if other pool already uses specified tag.</p> <p>Also you can remove pool by calling <code>Pooler.TryRemovePool(string tag)</code>.</p>"},{"location":"toolbox/pooler/#scene-pools","title":"Scene pools","text":"<p>What if you want to use some pools on the specific scene? Manually creating and removing pools each time seems boring and complicated. For this reason Toolbox has a <code>Scene Pool</code> component, which automatically creates specified pools when scene is loaded and removes them when it is unloaded.</p> <p></p>"},{"location":"toolbox/pooler/#creating-objects","title":"Creating objects","text":"<p>It is recommended to create all object by using <code>Pooler</code>, because it works with <code>Updater</code> and initializes objects to work properly with Toolbox.</p> <p>An alternative to basic Unity's <code>Instantiate(...)</code> method is <code>Pooler.Instantite(...)</code>. Use it when you need to create object without using pool.</p>"},{"location":"toolbox/pooler/#destroying-objects","title":"Destroying objects","text":"<p>IMPORTANT! Do not destroy objects that created by <code>Pooler.Spawn(...)</code> method, use <code>Pooler.TryDespawn(GameObject obj)</code> instead. It will remove object from processing and returns it back to pool. </p> <p>If you do not know exactly what object are you working with, use <code>Pooler.DespawnOrDestroy(GameObject obj)</code> method, so <code>Pooler</code> decides for itself to destroy or despawn object. If object are part of any existing pool it will be despawned otherwise it will be destroyed.</p> <p>Both methods returns bool that indicates if objects despawned or destroyed or not.</p>"},{"location":"toolbox/pooler/#scene-operations-handling","title":"Scene operations handling","text":"<p>There might be situation when you unloading scene that contains spawned objects. What will happen to this objects? Pooler automatically checks if you are unloading scene, thanks to Messenger, and returns all spawned objects back to its pools. So you can safely load and unload scenes, <code>Pooler</code> will handle all necessary stuff.</p>"},{"location":"toolbox/pooler/#garbage-collector","title":"Garbage Collector","text":"<p>When you spawn a lot of objects, then after some amount of time you ends up with a bunch of objects that you don't need, but they are still in memory.  To solve this problem <code>Pooler</code> has a 'Garbage Collector', that cleans up all objects in pools until they holds an initial capacity of objects.</p> <p>Garbage collector works by checking all pools every amount of time you specified in 'Toolbox Settings'. If a pool holds more objects than initial capacity, then the extra objects will be destroyed.</p> <p>You can manually tell to garbage collector to clean up pools by calling <code>Pooler.ForceGarbageCollector()</code>.</p>"},{"location":"toolbox/setup/","title":"Setup","text":"<p>Once you install the package, you will see setup screen:</p> <p></p> <p>If you don't, just open it from <code>Toolbox/Setup Screen</code></p> <p>First you need to initialize main scene, click 'Initialize Main Scene' button to do this.  This will add 'MAIN' scene to <code>Assets/Scenes/</code> folder and in build settings scenes list.  Then you need to create some settings data, click 'Create Settings Data' to do this.</p> <p>After all preparations completed, you can open 'Toolbox Settings' by clicking 'Open Toolbox Settings' or open it from <code>Toolbox/Settings</code>.</p>"},{"location":"toolbox/toolbox-settings/","title":"Toolbox Settings","text":"<p>From this window you can adjust main settings, edit initial pools, set up audios and edit properties in database.</p> <p>'Toolbox Settings' window has four tabs:</p> <ul> <li>Main Settings</li> <li>Pooler</li> <li>Audio Player</li> <li>Database</li> </ul> <p>Let's look all them.</p>"},{"location":"toolbox/toolbox-settings/#main-settings","title":"Main Settings","text":"<p>There you can edit following properties:</p> <ul> <li><code>Resolve Scenes On Play</code>: Changes OnPlay behaviour. If enabled, then Toolbox will close all opened scenes and start all with <code>MAIN</code> scene (after stop playing, all scenes will be restored).</li> <li><code>Time Scale</code>: An ordinary time scale, that affects all scripts, derived from <code>MonoCached</code>.</li> <li><code>Target Frame Rate</code>: Default target frame rate option, which will be setted at startup.</li> <li><code>Initial Scene Name</code>: The scene that will be loaded first after <code>MAIN</code> scene loaded.</li> <li><code>Initial Scene Args</code>: Arguments for initial scene.</li> <li><code>Manual Fade Out</code>: If enabled, then you can manually control when black screen will be faded out after initial scene loaded, otherwise Toolbox automatically fades it out right after initial scene loaded.</li> <li><code>Fade Out Duration</code>: Simply controls fade out duration when <code>Manual Fade Out</code> disabled.</li> </ul>"},{"location":"toolbox/toolbox-settings/#pooler","title":"Pooler","text":"<p>From this window you can edit initial pools list and adjust properties of each.</p> <p>You can create new pool by clicking 'Add Pool' button.</p> <p></p> <p>Each pool has following parameters:</p> <ul> <li><code>Pool Tag</code>: The tag, through which you can retrieve pooled object.</li> <li><code>Prefab</code>: Prefab which pool will instantiate objects.</li> <li><code>Initial Pool Size</code>: Count of an objects tha will be added to the pool at start.</li> </ul> <p></p> <p>To delete pool, simply click button with trash icon.</p> <p>You can also search necessary pool by writing its tag in search field.</p>"},{"location":"toolbox/toolbox-settings/#audio-player","title":"Audio Player","text":"<p>From this window you can edit audio albums list and adjust properties of each.</p> <p>You can create new album by clicking 'Add Album' button.</p> <p></p> <p>Each album has following parameters:</p> <ul> <li><code>Album Name</code>: Name of the album, through which you can get access to clips it containing.</li> <li><code>Use Separate Audio Source</code>: If enabled, then Toolbox will create separate audio source for this album.</li> <li><code>Mixer Group</code>: Mixer group through which you can control volume, effects etc of the audio source, binded to this album.</li> </ul> <p>To delete album click button with trash icon.</p> <p>To add clips in album click 'Add Clip' button.</p> <p></p> <p>Each clip has following parameters:</p> <ul> <li><code>Clip ID</code>: ID of the clip, through which you can retrieve it.</li> <li><code>Audio Clip</code>: Actual audio clip asset.</li> </ul> <p></p> <p>To delete clip click button with trash icon.</p>"},{"location":"toolbox/toolbox-settings/#database","title":"Database","text":"<p>From this window you can define database for your project. If you opening it first time it will look like this:</p> <p></p> <p>To create new database right click in project window and go to <code>Create/Toolbox/Properties Database</code>. It will create new scriptable object with all variables in it. Rename it as you wish and drag into 'Properties' fieeld in 'Database' tab of Toolbox Settings window. After adding database you can define your propertiess.</p> <p></p> <p>To add new property click '+' button.</p> <p></p> <p>Each property has following parameters:</p> <ul> <li><code>ID</code>: ID of the property, through which you can retrieve it.</li> <li><code>Type</code>: Type of the property. Can be one of the following: <code>Bool</code>, <code>Float</code>, <code>Int</code>, <code>Vector2</code>, <code>Vector3</code>, <code>Vector4</code>, <code>String</code>.</li> <li><code>Value</code>: Actual value of the property.</li> </ul> <p></p> <p>To delete property click button with trash icon.</p>"},{"location":"toolbox/traveler/","title":"Traveler","text":"<p><code>Traveler</code> class allows you to easily load/unload scenes (additevely or not) and provides UniTasks for you to manage your call orders in code. It also handles initial logic in scenes.</p>"},{"location":"toolbox/traveler/#scene-handler","title":"Scene Handler","text":"<p>Let's imagine that you need some initial preparations in scene before all starts working. To do this, you can define your own <code>SceneHandler</code> for this.</p> <pre><code>public class GameSceneHandler: SceneHandler&lt;GameSceneArgs&gt;\n{\n    protected override void SetupScene(GameSceneArgs args)\n    {\n\n    }\n}\n\npublic class GameSceneArgs: SceneArgs\n{\n\n}\n</code></pre> <p>Wait a minute! What this GameSceneArgs class means?! </p> <p>Exactly what you're thinking about! You can provide additional data to the scene when loading it, e.g. you need to create several levels with different difficulties. Creating a scene for each difficulty seems weird, because you have to recreate most of the objects each time if your scene stays the same in general. Instead of that you can set up one scene and change it's logic depending on data provided to it.</p> <p>Here's some example:</p> <pre><code>public class PingPongSceneHandler: SceneHandler&lt;PingPongSceneArgs&gt;\n{\n    [SerializeField] private Enemy m_Enemy;\n\n    protected override void SetupScene(PingPongSceneArgs args)\n    {\n        m_Enemy.SetSpeed(args.EnemySpeed);\n    }\n}\n\n[Serializable]\npublic class PingPongSceneArgs: SceneArgs\n{\n    public float EnemySpeed;\n}\n</code></pre> <p>In that example we're setting up enemy's speed defined by <code>PingPongSceneArgs</code>. <code>SceneArgs</code> class derived from <code>ScriptableObject</code>, so you can create some <code>PingPongSceneArgs</code> assets and bind it to difficulty buttons in your menu scene.</p> <p>You can also override <code>OnSceneUnload</code> method, to do some logic before scene unloads.</p>"},{"location":"toolbox/traveler/#scene-loading","title":"Scene Loading","text":"<p>To load scene simply call:</p> <pre><code>Traveler.LoadScene(\"MySceneName\", new MySceneArgs { data = \"Hello World!\" });\n</code></pre> <p>It will return a UniTask, so you can await it, to manage your calls if you need:</p> <pre><code>await Fader.In(0.2f); \nawait Traveler.LoadScene(\"MySceneName\");\nawait Fader.Out(0.2f);\n</code></pre>"},{"location":"toolbox/traveler/#scene-unloading","title":"Scene Unloading","text":"<p>To unload scene simply call:</p> <pre><code>Traveler.UnloadScene(\"MySceneName\");\n</code></pre> <p>You can also unload all scenes, except <code>MAIN</code>, by calling:</p> <pre><code>Traveler.UnloadAllScenes();\n</code></pre> <p>This methods will also returns a UniTask.</p>"},{"location":"toolbox/traveler/#loading-order","title":"Loading order","text":"<p>After calling <code>LoadScene</code> of Traveler's class, it will be waiting before current operations (loading/unloading scenes) finished his work. Then scene will be loaded usually, and <code>SceneLoadingMessage</code> will be fired. After scene finished loading <code>SceneLoadedMessage</code> fires and all objects in scene will be traversed. If any object contains <code>SceneHandler</code>, then it will be initialized by <code>Updater</code> and starts preparing scene. Then all objects in scene will be initialized and <code>SceneOpenedMessage</code> fires.</p> <p>On <code>UnloadScene</code> call it will be wait until current operations (loading/unloading scenes) done it's work. Then <code>SceneUnloadingMessage</code> fires, if <code>SceneHandler</code> on this scene exists, then <code>OnSceneUnload</code> method invokes and all objects in scene removes from <code>Updater</code> processing. Finally, it unloads scene usually, waits for it's finish and fires <code>SceneUnloadedMessage</code>.</p>"},{"location":"toolbox/updater/","title":"Updater","text":"<p><code>Updater</code> is a base class for process and initialize <code>MonoCached</code> classes. Also you can control time scale for all monos independently of basic Unity's time scale. You can get access to delta time impacted by setted time scale.</p> <p>Here's list of all methods and properties available for managing objects:</p> Method Description <code>UnscaledDelta</code> Returns default <code>Time.deltaTime</code> <code>TimeScale</code> Returns current <code>Updater</code>'s time scale, or sets it to value between 0 and infinite <code>Delta</code> Returns current delta time multiplied by <code>Updater</code>'s time scale <code>InitializeObjects(GameObject[] objs)</code> Invokes Rise and Ready on given GameObjects, and then adds them to process <code>RemoveObjectsFromUpdate(GameObject[] objs)</code> Removes all GameObjects from process <code>InitializeObject(GameObject obj)</code> Invokes Rise and Ready on given GameObject, and then adds it to process <code>InitializeMono(MonoCached mono)</code> Invokes Rise and Ready on given MonoCached, and then adds it to process <code>RemoveMonoFromUpdate(MonoCached mono)</code> Removes given MonoCached from process"}]}