{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>There you can find documentation and link for all my projects :)</p> <p>My GitHub Profile</p> <p>List of all projects documentation:</p> <ul> <li>Toolbox</li> </ul>"},{"location":"toolbox/about/","title":"About","text":"<p>Toolbox is a framework that makes it easier to create games using Unity. Many frequently used features by programmers are taken into account in the toolbox and configured in such a way as to reduce the time and number of lines of code spent on them.</p>"},{"location":"toolbox/about/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installing</li> <li>Setup</li> <li>Dependencies</li> <li>Toolbox Settings</li> <li>MonoCached</li> <li>Updater</li> <li>Traveler</li> <li>Pooler</li> <li>Messenger</li> <li>Audio Player</li> <li>DI Solutions](di.md)[Using Along with </li> </ul>"},{"location":"toolbox/audioplayer/","title":"Audio Player","text":""},{"location":"toolbox/audioplayer/#basics","title":"Basics","text":"<p><code>AudioPlayer</code> allows you to structure sounds used in your project and manipulate them. It uses albums as containers for clips; each album can have its own audio source component bound and can be controlled through a mixer group.</p> <p>To configure the root for new audio sources and the default audio source, go to the 'MAIN' scene. In the <code>Audio Player</code> component of the 'Toolbox Container' game object, set everything as needed.</p> <p></p>"},{"location":"toolbox/audioplayer/#adding-clips","title":"Adding Clips","text":"<p>To add an album, go to Toolbox settings and click on the 'Audio Player' tab. Here you can add a new album by clicking the 'Add Album' button. Enter its name and decide if you want to use a separate audio source or use the default. If you are using a separate source, you can define a mixer group for it if you want.</p> <p></p> <p>Each album has the following parameters:</p> <ul> <li><code>Album Name</code>: The name of the album, through which you can access the clips it contains.</li> <li><code>Use Separate Audio Source</code>: If enabled, Toolbox will create a separate audio source for this album.</li> <li><code>Mixer Group</code>: The mixer group through which you can control the volume, effects, etc., of the audio source bound to this album.</li> </ul> <p>To delete an album, click the button with the trash icon.</p> <p>After setting up the album, click on the 'Add Clip' button to add a new audio clip. Enter its name, select the actual audio clip, and adjust the volume you want it to play with. You can also preview it by clicking the 'Play' button or stop playing by clicking the 'Stop' button below the 'Play' button or right after the 'Add Album' button.</p> <p></p> <p>Each clip has the following parameters:</p> <ul> <li><code>Clip ID</code>: The ID of the clip, through which you can retrieve it.</li> <li><code>Audio Clip</code>: The actual audio clip asset.</li> </ul> <p>To delete a clip, click the button with the trash icon.</p>"},{"location":"toolbox/audioplayer/#selecting-audio-clips-in-inspector","title":"Selecting Audio Clips in Inspector","text":"<p>To easily choose which clip you want to play, you can expose a string field by adding the <code>[AudioPlayerClip]</code> tag.</p> <p></p> <p>There you can select an album and clip or enter it manually by clicking the button with the pen icon. To end manual editing, click the button again.</p>"},{"location":"toolbox/audioplayer/#playing-audios","title":"Playing Audios","text":"<p>To play audio, you can call one of the following methods:</p> <ul> <li><code>AudioPlayer.Play(source, id, volume, pitch, loop, playType)</code>:<ul> <li><code>source</code>: The album name.</li> <li><code>id</code>: The clip name.</li> <li><code>volume</code>: The volume of the AudioSource component (default = 1).</li> <li><code>pitch</code>: The pitch of the AudioSource component (default = 1).</li> <li><code>loop</code>: Whether the audio clip will be looped (default = false).</li> <li><code>playType</code>: The play behavior (default = ONE_SHOT):<ul> <li><code>ONE_SHOT</code>: Plays the clip even if another clip is playing.</li> <li><code>STOP_THEN_PLAY</code>: Stops the current playing clip if there is one and then plays the provided clip.</li> <li><code>NO_INTERRUPT</code>: Does nothing if another clip is currently playing; otherwise, plays it normally.</li> </ul> </li> <li>This method has overloads that allow you to manually provide an AudioSource or AudioClip to play.</li> </ul> </li> <li><code>AudioPlayer.PlayFormatted(formattedId, volume, pitch, loop, playType)</code>:<ul> <li><code>formattedId</code>: A string in the format \"[Album_Name]/[Clip_ID]\".</li> <li>Use this method to play clips you selected through the inspector.</li> </ul> </li> </ul> <p>By default, in all methods above, the volume parameter is set to -1. By doing this, <code>AudioPlayer</code> will choose the volume you set up in the related clip in the Audio Player tab in Toolbox Settings. Otherwise, it will use the value you provided.</p>"},{"location":"toolbox/dependencies/","title":"Dependencies","text":"<p>Toolbox uses other packages to work properly, here yo can see all of them with links related.</p> <ul> <li>UniTask: used to easily work with async/await in unity environment</li> </ul>"},{"location":"toolbox/di/","title":"Using along with DI solutions","text":""},{"location":"toolbox/di/#basics","title":"Basics","text":""},{"location":"toolbox/install/","title":"Installing","text":""},{"location":"toolbox/install/#install-with-openupm","title":"Install with OpenUPM","text":"<p>Once you have the OpenUPM cli, run the following command:</p> <ul> <li>Go to your Unity project directory</li> </ul> <p><code>cd YOUR_UNITY_PROJECT_DIR</code></p> <ul> <li>Install package: com.volumebox.toolbox</li> </ul> <p><code>openupm add com.volumebox.toolbox</code></p> <p>Alternatively, merge the snippet to Packages/manifest.json </p> <pre><code>{\n    \"scopedRegistries\": [\n        {\n            \"name\": \"package.openupm.com\",\n            \"url\": \"https://package.openupm.com\",\n            \"scopes\": [\n              \"com.volumebox\"\n              \"com.openupm\"\n            ]\n        }\n    ],\n    \"dependencies\": {\n        \"com.volumebox.toolbox\": \"0.2.4\"\n    }\n}\n</code></pre>"},{"location":"toolbox/install/#install-via-package-manager","title":"Install via Package Manager","text":"<ul> <li>open Edit/Project Settings/Package Manager</li> <li> <p>add a new Scoped Registry (or edit the existing OpenUPM entry)</p> <p>Name: <code>package.openupm.com</code></p> <p>URL: <code>https://package.openupm.com</code></p> </li> <li> <p>add following scopes:</p> <p><code>com.volumebox.toolbox</code></p> <p><code>com.cysharp</code></p> </li> <li> <p>click <code>Save</code> (or <code>Apply</code>)</p> </li> <li>open <code>My Registries</code> packages in package manager window</li> <li>install <code>VolumeBox Toolbox</code></li> </ul>"},{"location":"toolbox/messenger/","title":"Messenger","text":""},{"location":"toolbox/messenger/#basics","title":"Basics","text":"<p>Toolbox implements a publisher-subscriber pattern, that allows you to write minimally coupled code in fewer lines.  You can read more about publisher-subscriber pattern Here.</p> <p>To use this pattern you need to work with <code>Messenger</code> class, which allows you to subscribe and send messages by calling <code>Messenger.Subscribe&lt;T&gt;(...)</code> and <code>Messenger.Send&lt;T&gt;()</code> correspondingly.</p>"},{"location":"toolbox/messenger/#message","title":"Message","text":"<p>To work with messages you need to create one. <code>Message</code> is a basic class for all messages, just derive your message from it, add fields and properties and that's it.</p> <pre><code>public class PlayerReloadingMessage: Message { }\n\npublic class EnemyDiedMessage: Message\n{\n    public Enemy enemy;\n}\n</code></pre>"},{"location":"toolbox/messenger/#subscribing","title":"Subscribing","text":"<p>To subscribe to a message, you need provide its type and a callback to a <code>Messenger.Subscribe&lt;T&gt;(...)</code> method.</p> <pre><code>...\n\nprotected override void Rise()\n{\n    Messenger.Subscribe&lt;PlayerReloadingMessage&gt;(_ =&gt; OnPlayerReloading());\n    Messenger.Subscribe&lt;EnemyDiedMessage&gt;(m =&gt; OnEnemyDied(m));\n}\n\nprivate void OnPlayerReloading()\n{\n    // Do something when player reloading\n}\n\nprivate void OnEnemyDied(Enemy enemy)\n{\n    m_KilledEnemies.Add(enemy);\n}\n\n...\n</code></pre>"},{"location":"toolbox/messenger/#sending","title":"Sending","text":"<p>You can send messages in several ways:</p>"},{"location":"toolbox/messenger/#by-type","title":"By type","text":"<p>If you do not have additional data to provide with message, you can just provide message's type.</p> <pre><code>...\n\nMessenger.Send&lt;PlayerReloadingMessage&gt;();\n\n...\n</code></pre>"},{"location":"toolbox/messenger/#by-instance","title":"By instance","text":"<p>If you want to pass additional data to a message, you need to create an instance of it and provide it as a parameter.</p> <pre><code>...\n\nMessenger.Send(new EnemyDiedMessage { enemy = this });\n\n...\n</code></pre>"},{"location":"toolbox/messenger/#by-cached-variable","title":"By cached variable","text":"<p>If you often send a one type of message with different data, you can cache it and send it without creating a new instance.</p> <pre><code>...\n\nprivate GainedXPMessage m_GainedXPMessage = new GainedXPMessage();\n\n...\n\npublic void OnXpGained(int amount)\n{\n    //do related stuff\n\n    //update message's variable\n    m_GainedXPMessage.amount = amount; \n    //then send a message\n    Messenger.Send(m_GainedXPMessage);\n}\n\n...\n</code></pre>"},{"location":"toolbox/messenger/#binding","title":"Binding","text":"<p>You can bind your subscribe to a gameobject lifetime, so it will be automatically removed if gameobject destroyed to prevent memory leaks and errors. Just provide gameobject you want to bind as second parameter.</p> <pre><code>Messenger.Subscribe&lt;PlayerReloadingMessage&gt;(_ =&gt; OnPlayerReloading, gameObject);\n</code></pre>"},{"location":"toolbox/monocached/","title":"MonoCached","text":""},{"location":"toolbox/monocached/#basics","title":"Basics","text":"<p>Toolbox has its own update system, which wraps around Unity's basic update cycle and performs its own calculations.</p> <p><code>MonoCached</code> is the main component of this system. It is analogous to MonoBehaviour with some extra features described below.</p> <p><code>MonoCached</code> has the same update cycle-related methods, but they are named differently. It is closely related to <code>Updater</code>, so you can precisely control the lifetime and update behavior of each object. Here is a list of all \"overridden\" methods recommended for use instead:</p> Basic Analogue <code>Awake</code> <code>Rise</code> <code>Start</code> <code>Ready</code> <code>Update</code> <code>Tick</code> <code>FixedUpdate</code> <code>FixedTick</code> <code>LateUpdate</code> <code>LateTick</code> <code>OnDestroy</code> <code>Destroyed</code> <code>OnEnable</code> <code>OnActivate</code> <code>OnDisable</code> <code>OnDeactivate</code> <p>Additionally, <code>MonoCached</code> has methods and properties to control its lifecycle:</p> Method Description <code>Pause</code> Pauses the execution of <code>Tick</code>, <code>FixedTick</code>, and <code>LateTick</code> methods. <code>Resume</code> Resumes the execution of <code>Tick</code>, <code>FixedTick</code>, and <code>LateTick</code> methods. <code>EnableGameObject</code> Enables the <code>gameObject</code> on which the component is placed. <code>DisableGameObject</code> Disables the <code>gameObject</code> on which the component is placed. <code>ProcessIfInactiveSelf</code> Bool property. If enabled, <code>Tick</code>, <code>FixedTick</code>, and <code>LateTick</code> methods will be executed even if the <code>gameObject</code> is inactive self. <code>ProcessIfInactiveInHierarchy</code> Bool property. If enabled, <code>Tick</code>, <code>FixedTick</code>, and <code>LateTick</code> methods will be executed even if the <code>gameObject</code> is inactive in the hierarchy. <code>delta</code> Float property. Delta time, controlled by timescale, interval, etc. <code>fixedDelta</code> Float property. Fixed delta time, controlled by timescale, interval, etc. <code>Interval</code> Float property. Sets the interval between calling <code>Tick</code>, <code>FixedTick</code>, and <code>LateTick</code> methods. Delta time will then be the sum of deltas between the last call and the next. If set to 0, it works as usual. <p>To utilize the full power of 'Toolbox', simply derive your class from <code>MonoCached</code> and override the methods you need.</p> <p>Here's an example:</p> <pre><code>public class Rocket : MonoCached\n{\n    private float speed = 10;\n    private SpriteRenderer spriteRenderer;\n\n    protected override void Rise()\n    {\n        spriteRenderer = GetComponent&lt;SpriteRenderer&gt;();\n    }\n\n    protected override void Tick()\n    {\n        // Here we reduce update calls if we don't see the object\n        if (/* There is some logic to check if the object is out of the screen */)\n        {\n            Interval = 1;\n        }\n        else\n        {\n            Interval = 0;\n        }\n\n        // Delta time will be the sum of deltas on every frame between the last call of this method and the current\n        transform.position = transform.forward * speed * delta;\n    }\n}\n</code></pre> <p>Because <code>MonoCached</code> is derived from MonoBehaviour, you can still use <code>Awake</code>, <code>Update</code>, etc.</p>"},{"location":"toolbox/pooler/","title":"Pooler","text":""},{"location":"toolbox/pooler/#basics","title":"Basics","text":"<p>Let's start this topic by defining what 'Pool' means. Here you can read all about this pattern: </p> <p>Object pool pattern.</p> <p>In simple words, use the pool pattern when you are working with a lot of instantiating and destroying objects.</p> <p>Toolbox has its own implementation of this pattern. A simple way you can use it is to define pools you need in Toolbox settings and call <code>Pooler.Spawn(...)</code> where you need.</p> <pre><code>...\n\npublic void Shoot()\n{\n    var bullet = Pooler.Spawn(\"Bullet\", currentWeapon.tip.position, Quaternion.identity).GetComponent&lt;Bullet&gt;();\n    bullet.StartMovingForward();\n}\n\n...\n</code></pre> <p>To configure where pooled objects will be contained, go to the 'MAIN' scene. In the <code>Pooler</code> component of the 'Toolbox Container' game object, set your own <code>Transform</code> in the <code>Predefined Root</code> field.</p> <p></p> <p>By default, it will create a new root at runtime in the 'MAIN' scene.</p>"},{"location":"toolbox/pooler/#adding-pool","title":"Adding pool","text":"<p>To create pools, which will be initialized on start, go to 'Toolbox Settings' and click on the 'Pooler' tab. Here you can add or remove pools, change their tags, prefabs and capacity, and set the garbage collector's interval.</p> <p></p> <p>You can create a new pool by clicking the 'Add Pool' button.</p> <p></p> <p>Each pool has the following parameters:</p> <ul> <li><code>Pool Tag</code>: The tag through which you can retrieve a pooled object.</li> <li><code>Prefab</code>: Prefab which the pool will instantiate objects from.</li> <li><code>Initial Pool Size</code>: Count of objects that will be added to the pool at start.</li> </ul> <p></p> <p>To delete a pool, simply click the button with the trash icon.</p> <p>The size of the pool also describes how many objects you can spawn without instantiating a new one when it's all over.</p> <p>You can create a pool manually in code by calling <code>Pooler.TryAddPool(PoolData poolToAdd)</code> or <code>Pooler.TryAddPool(string tag, GameObject prefab, int capacity)</code>. The pool won't be added if another pool already uses the specified tag.</p> <p>You can also remove a pool by calling <code>Pooler.TryRemovePool(string tag)</code>.</p>"},{"location":"toolbox/pooler/#scene-pools","title":"Scene pools","text":"<p>What if you want to use some pools in a specific scene? Manually creating and removing pools each time seems boring and complicated. For this reason, Toolbox has a <code>Scene Pool</code> component, which automatically creates specified pools when the scene is loaded and removes them when it is unloaded.</p> <p></p>"},{"location":"toolbox/pooler/#creating-objects","title":"Creating objects","text":"<p>It is recommended to create all objects by using <code>Pooler</code>, because it works with <code>Updater</code> and initializes objects to work properly with Toolbox.</p> <p>An alternative to Unity's basic <code>Instantiate(...)</code> method is <code>Pooler.Instantiate(...)</code>. Use it when you need to create an object without using a pool.</p>"},{"location":"toolbox/pooler/#destroying-objects","title":"Destroying objects","text":"<p>IMPORTANT! Do not destroy objects that are created by the <code>Pooler.Spawn(...)</code> method, use <code>Pooler.TryDespawn(GameObject obj)</code> instead. It will remove the object from processing and return it back to the pool.</p> <p>If you do not know exactly what object you are working with, use the <code>Pooler.DespawnOrDestroy(GameObject obj)</code> method, so <code>Pooler</code> decides for itself whether to destroy or despawn the object. If the object is part of any existing pool, it will be despawned; otherwise, it will be destroyed.</p> <p>Both methods return a bool that indicates whether the object was despawned or destroyed or not.</p>"},{"location":"toolbox/pooler/#scene-operations-handling","title":"Scene operations handling","text":"<p>There might be a situation when you are unloading a scene that contains spawned objects. What will happen to these objects? Pooler automatically checks if you are unloading a scene, thanks to Messenger, and returns all spawned objects back to their pools. So you can safely load and unload scenes, <code>Pooler</code> will handle all necessary stuff.</p>"},{"location":"toolbox/pooler/#garbage-collector","title":"Garbage Collector","text":"<p>When you spawn a lot of objects, after some amount of time you end up with a bunch of objects that you don't need, but they are still in memory.  To solve this problem, <code>Pooler</code> has a 'Garbage Collector' that cleans up all objects in pools until they hold an initial capacity of objects.</p> <p>The garbage collector works by checking all pools every amount of time you specified in 'Toolbox Settings'. If a pool holds more objects than the initial capacity, then the extra objects will be destroyed.</p> <p>You can manually tell the garbage collector to clean up pools by calling <code>Pooler.ForceGarbageCollector()</code>.</p>"},{"location":"toolbox/setup/","title":"Setup","text":"<p>Once you install the package, you will see the setup screen:</p> <p></p> <p>If you don't see it, you can open it from <code>Toolbox/Setup Screen</code>.</p> <p>First, you need to initialize the main scene. Click the 'Initialize Main Scene' button to do this. This will add the 'MAIN' scene to the <code>Assets/Scenes/</code> folder and include it in the build settings scenes list.</p> <p>Next, you need to create some settings data. Click 'Create Settings Data' to do this.</p> <p>By default, the 'MAIN' scene should look like this:</p> <p></p> <p>On the <code>Toolbox Entry</code> component of the 'Toolbox Container' game object, make sure that the <code>Initialize On Start</code> boolean is enabled.</p> <p></p> <p>After all preparations are completed, you can open 'Toolbox Settings' by clicking 'Open Toolbox Settings' or accessing it from <code>Toolbox/Settings</code>.</p> <p>To gain access to Toolbox's components, use <code>Toolbox.Instance.[Class_You_Need]</code>.</p> <p>Here are the classes available:</p> <ul> <li><code>Messenger</code></li> <li><code>Pooler</code></li> <li><code>AudioPlayer</code></li> <li><code>Traveler</code></li> <li><code>Updater</code></li> </ul>"},{"location":"toolbox/toolbox-settings/","title":"Toolbox Settings","text":""},{"location":"toolbox/toolbox-settings/#basics","title":"Basics","text":"<p>From this window, you can adjust main settings, edit initial pools, set up audios, and edit properties in the database.</p> <p>The 'Toolbox Settings' window has three tabs:</p> <ul> <li>Main Settings</li> <li>Pooler</li> <li>Audio Player</li> </ul> <p>Let's look at all of them.</p>"},{"location":"toolbox/toolbox-settings/#main-settings","title":"Main Settings","text":"<p>In this tab, you can edit the following properties:</p> <ul> <li><code>Resolve Scenes On Play</code>: Changes the OnPlay behavior. If enabled, Toolbox will close all opened scenes and start all with the <code>MAIN</code> scene (after stopping play, all scenes will be restored).</li> <li><code>Time Scale</code>: The ordinary time scale that affects all scripts derived from <code>MonoCached</code>.</li> <li><code>Target Frame Rate</code>: The default target frame rate option, which will be set at startup.</li> <li><code>Initial Scene Name</code>: The scene that will be loaded first after the <code>MAIN</code> scene is loaded.</li> <li><code>Initial Scene Args</code>: Arguments for the initial scene.</li> <li><code>Message Caching</code>: Indicates whether message caching should be enabled (see Messenger).</li> </ul>"},{"location":"toolbox/toolbox-settings/#pooler","title":"Pooler","text":"<p>From this window, you can edit the initial pools list, adjust the properties of each pool, and set the garbage collector interval.</p>"},{"location":"toolbox/toolbox-settings/#audio-player","title":"Audio Player","text":"<p>From this window, you can edit the audio albums list and adjust the properties of each album.</p>"},{"location":"toolbox/traveler/","title":"Traveler","text":"<p>The <code>Traveler</code> class allows you to easily load and unload scenes (additively or not) and provides UniTasks to manage your call orders in code. It also handles initial logic in scenes.</p>"},{"location":"toolbox/traveler/#scene-handler","title":"Scene Handler","text":"<p>Imagine you need some initial preparations in a scene before everything starts working. To do this, you can define your own <code>SceneHandler</code> for the scene.</p> <pre><code>public class GameSceneHandler : SceneHandler&lt;GameSceneArgs&gt;\n{\n    protected override void SetupScene(GameSceneArgs args)\n    {\n        // Initialization logic here\n    }\n}\n\npublic class GameSceneArgs : SceneArgs\n{\n    // Define additional data here\n}\n</code></pre>"},{"location":"toolbox/traveler/#what-is-the-gamesceneargs-class","title":"What is the <code>GameSceneArgs</code> Class?","text":"<p>The <code>GameSceneArgs</code> class allows you to provide additional data to the scene when loading it. For example, you might need to create several levels with different difficulties. Instead of creating a separate scene for each difficulty, you can set up one scene and change its logic based on the data provided to it.</p> <p>Here's an example:</p> <pre><code>public class PingPongSceneHandler : SceneHandler&lt;PingPongSceneArgs&gt;\n{\n    [SerializeField] private Enemy m_Enemy;\n\n    protected override void SetupScene(PingPongSceneArgs args)\n    {\n        m_Enemy.SetSpeed(args.EnemySpeed);\n    }\n}\n\n[Serializable]\npublic class PingPongSceneArgs : SceneArgs\n{\n    public float EnemySpeed;\n}\n</code></pre> <p>In this example, we set the enemy's speed defined by <code>PingPongSceneArgs</code>. The <code>SceneArgs</code> class is derived from <code>ScriptableObject</code>, so you can create multiple <code>PingPongSceneArgs</code> assets for each difficulty and bind them to difficulty buttons in your menu scene.</p> <p>You can also override the <code>OnUnloadCallback</code> method to perform some logic before the scene unloads.</p>"},{"location":"toolbox/traveler/#scene-loading","title":"Scene Loading","text":"<p>To load a scene, simply call:</p> <pre><code>Traveler.LoadScene(\"MySceneName\", new MySceneArgs { data = \"Hello World!\" });\n</code></pre> <p>This method returns a UniTask, so you can await it to manage your calls if needed:</p> <pre><code>await Fader.In(0.2f);\nawait Traveler.LoadScene(\"MySceneName\");\nawait Fader.Out(0.2f);\n</code></pre>"},{"location":"toolbox/traveler/#scene-unloading","title":"Scene Unloading","text":"<p>To unload a scene, simply call:</p> <pre><code>Traveler.UnloadScene(\"MySceneName\");\n</code></pre> <p>You can also unload all scenes except <code>MAIN</code> by calling:</p> <pre><code>Traveler.UnloadAllScenes();\n</code></pre> <p>These methods also return a UniTask.</p> <p>The <code>LoadScene</code> method has an overload that allows you to get the <code>SceneHandler</code>. If you know the type of <code>SceneHandler</code> for the scene you are loading, you can use this type as a generic:</p> <pre><code>var handler = await Traveler.LoadScene&lt;PingPongSceneHandler&gt;();\n</code></pre> <p>If you want to get the <code>SceneHandler</code> after opening a scene, you can still do that using the following syntax:</p> <pre><code>var handler = Traveler.TryGetSceneHandler&lt;PingPongSceneHandler&gt;();\n</code></pre> <p>or</p> <pre><code>var handlers = Traveler.TryGetAllSceneHandlers&lt;PingPongSceneHandler&gt;();\n</code></pre> <p>if you have multiple scenes with this type of handler.</p>"},{"location":"toolbox/traveler/#loading-order","title":"Loading Order","text":"<p>After calling the <code>LoadScene</code> method of the <code>Traveler</code> class, it will wait for the current operations (loading/unloading scenes) to finish. Then the scene will be loaded as usual, and a <code>SceneLoadingMessage</code> will be fired. After the scene finishes loading, a <code>SceneLoadedMessage</code> fires, and all objects in the scene will be traversed. If any object contains a <code>SceneHandler</code>, it will be initialized by the <code>Updater</code> and will start preparing the scene. Then all objects in the scene will be initialized, and a <code>SceneOpenedMessage</code> will fire.</p> <p>IMPORTANT! The scene handler must be a root game object in the scene.</p> <p>On the <code>UnloadScene</code> call, it will wait until the current operations (loading/unloading scenes) are done. Then a <code>SceneUnloadingMessage</code> fires. If a <code>SceneHandler</code> exists on this scene, the <code>OnSceneUnload</code> method will be invoked, and all objects in the scene will be removed from the <code>Updater</code> processing. Finally, it unloads the scene as usual, waits for it to finish, and fires a <code>SceneUnloadedMessage</code>.</p>"},{"location":"toolbox/updater/","title":"Updater","text":"<p><code>Updater</code> is a base class for processing and initializing <code>MonoCached</code> classes. It also allows you to control the time scale for all monos independently of Unity's basic time scale. You can access delta time impacted by the set time scale.</p> <p>Here is a list of all methods and properties available for managing objects:</p> Method Description <code>UnscaledDelta</code> Returns the default <code>Time.deltaTime</code>. <code>TimeScale</code> Returns the current <code>Updater</code>'s time scale or sets it to a value between 0 and infinity. <code>Delta</code> Returns the current delta time multiplied by the <code>Updater</code>'s time scale. <code>InitializeObjects(GameObject[] objs)</code> Invokes <code>Rise</code> and <code>Ready</code> on the given GameObjects and then adds them to the process. <code>RemoveObjectsFromUpdate(GameObject[] objs)</code> Removes all given GameObjects from the process. <code>InitializeObject(GameObject obj)</code> Invokes <code>Rise</code> and <code>Ready</code> on the given GameObject and then adds it to the process. <code>InitializeMono(MonoCached mono)</code> Invokes <code>Rise</code> and <code>Ready</code> on the given <code>MonoCached</code> and then adds it to the process. <code>RemoveMonoFromUpdate(MonoCached mono)</code> Removes the given <code>MonoCached</code> from the process."}]}